# v0.3.1 - Máquina de Estado para Animaciones (Animation State Machine)

Resumen

- Añadir una máquina de estado determinista y ligera para controlar transiciones entre animaciones (idle, walk, jump, attack, etc.).
- Integración con `AnimationComponent` y `AnimationSystem` existente.
- Permitir triggers, condiciones y blending básico (cross-fade entre animaciones opcional).

Objetivos

- Definir un API clara para declarar estados y transiciones en código o JSON.
- Añadir un pequeño motor FSM que pueda ejecutar por entidad, con mínima alocación de memoria.
- Permitir triggers desde `EventSystem` y condiciones basadas en componentes (por ejemplo `velocity.y > 0`).

Diseño - data shapes

- AnimationState

  - name: string
  - animation: string (nombre de la animación en AnimationComponent)
  - onEnter?: { reset?: boolean, events?: Array<string> }
  - onExit?: { events?: Array<string> }

- Transition

  - from: string | '\*'
  - to: string
  - condition?: (entity) => boolean // función ejecutable o referencia a un predicate
  - trigger?: string // nombre de evento que dispara la transición
  - priority?: number // mayor prioridad ejecuta primero

- StateMachineDefinition
  - states: AnimationState[]
  - transitions: Transition[]
  - initial: string

Runtime

- Por entidad, la `AnimationStateMachineComponent` contendrá:

  - type: 'anim-machine'
  - defKey: string (clave para buscar definición compartida)
  - currentState: string
  - elapsed: number
  - params?: Record<string, any>

- `AnimationStateSystem` (nuevo) responsabilidades:
  - Evaluar transiciones en orden de prioridad cada frame (o en fixed update)
  - Ejecutar `onExit` y `onEnter` y aplicar `playAnimation(entity, animation)` en `AnimationSystem` o directamente modificar `AnimationComponent`.
  - Escuchar triggers del `EventSystem` si una transición los declara.

API de Declaración (ejemplo JS/TS)

```ts
const playerASM: StateMachineDefinition = {
  states: [
    { name: "idle", animation: "idle" },
    { name: "walk", animation: "walk" },
    { name: "jump", animation: "jump" },
    { name: "attack", animation: "attack" },
  ],
  transitions: [
    {
      from: "idle",
      to: "walk",
      condition: (e) => e.getComponent("input")?.moving,
    },
    { from: "*", to: "attack", trigger: "PLAYER_ATTACK", priority: 100 },
    {
      from: "walk",
      to: "idle",
      condition: (e) => !e.getComponent("input")?.moving,
    },
  ],
  initial: "idle",
};
```

Integración y rendimiento

- Las definiciones se guardan en un registro compartido para evitar duplicar objetos por entidad.
- El `AnimationStateSystem` debe iterar sólo entidades con `anim-machine` y `animation`.
- Para reducir coste, soportar evaluación por eventos (re-evaluar sólo cuando cambia `velocity` o se dispara un trigger) y un modo `pollingInterval` para entidades que requieren chequeo frecuente.

Pruebas mínimas

- Test: transición por condición (idle->walk) con cambio de componente `input.moving`.
- Test: trigger-based transition (reproducir attack cuando se emita event `PLAYER_ATTACK`).
- Test: onEnter reset de animación y emisión de evento.

Entregables

- `src/graphics/AnimationStateMachine.ts` - sistema y tipos
- `src/types/anim-state.d.ts` - tipos de definiciones
- `docs/v0.3.1-animations-state-machine.md` - esta especificación
- Tests en `tests/unit/animation-state-machine.test.ts`

---

Notas

- Mantener la implementación mínima, fácil de extender a blending/crossfade más adelante.
