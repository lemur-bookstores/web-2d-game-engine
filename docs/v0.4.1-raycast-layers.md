# v0.4.1 - Raycast & Collision Layers

Propósito

- Añadir un sistema de raycast dentro del `PhysicsWorld` y exponer una API para que sistemas y juegos realicen raycasts contra el mundo físico.
- Introducir un sistema de "layers" de colisión (bitmasks) y un contrato claro sobre si se define a nivel de `Engine` o a nivel de `Scene`.

Alcance

- Raycast API en `PhysicsWorld`: raycast(origin, direction, length, options) -> hits[]
- Layers de colisión configurables por escena (default global si no se especifica)
- Integración con `PhysicsBody` para asignar layer (category) y mask
- Tests unitarios e integración para raycasts y filtrado por layers
- Documentación de la elección de diseño (engine vs scene) y guía de migración

Requerimientos

- [ ] API de Raycast en `PhysicsWorld` con soporte para capas y filtros
- [ ] `PhysicsBodyConfig` incluye `collisionLayer` y `collisionMask` (ya existe category/mask)
- [ ] Decidir y documentar si las layers viven en Engine o Scene
- [ ] Implementar `RaycastResult` con información: hit point, normal, fraction, body/entity, fixture
- [ ] Tests: raycast hits, raycast filtered by mask, edge cases (parallel, origin inside body)
- [ ] Ejemplo de uso en `examples/physics-platformer` (raycast para detección suelo)

Diseño (alto nivel)

- Layers: usar bitmask (u16) igual que Box2D categoryBits/maskBits.
- Donde definir layers:
  - Recomendación: Mantener la tabla de `Layer` por escena (Scene.layers)
  - Motivo: permite escenas con configuraciones de colisión independientes (por ejemplo menú vs nivel de juego).
  - Fallback: si Scene no define layers, usar `Engine.defaultLayers` global.

API propuesta

- PhysicsWorld.raycast(origin: Vector2, direction: Vector2, length: number, options?: { layerMask?: number, includeSensors?: boolean }): RaycastResult[]

- RaycastResult {
  point: Vector2,
  normal: Vector2,
  fraction: number,
  body?: PhysicsBody,
  entityId?: string
}

Detalles de implementación

- Implementar uso de Box2D `RayCast` si `box2d` está disponible; en fallback, simular raycast con AABB query + fine intersection (no perfecto pero seguro para tests sin WASM).
- Respetar fixture.filter.maskBits/categoryBits cuando se filtra por `layerMask`.
- Exponer helper `Scene.getLayerMask(names: string[])` para traducir nombres de layer a bitmask.

Migración y compatibilidad

- `PhysicsBody` ya tiene `collisionCategory` y `collisionMask` — mapearlos a layers.
- Documentar cómo actualizar componentes existentes (cambiar collisionGroup -> category/mask).

Tests y validación

- Tests unitarios para `PhysicsWorld.raycast()` en modo Box2D y modo fallback.
- Test de integración donde un jugador hace raycast hacia abajo para detectar suelo.

Tareas inmediatas (MVP)

1. Añadir `PhysicsWorld.raycast()` y `RaycastResult` type
2. Añadir Scene.layers (opcional) y Engine.defaultLayers
3. Tests básicos y ejemplo platformer con raycast de suelo

Notas

- Mantener compatibilidad con variantes de Box2D diferentes y usar defensivas.
- No cambiar runtime de `PhysicsBody` sin tests que cubran moldeo de fixtures.

---

Fecha: 2025-08-26

Autogenerated by dev assistant
