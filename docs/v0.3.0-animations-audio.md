# v0.3.0 - Animaciones y Audio

Propósito

- Añadir un sistema de animaciones y un subsistema de audio para crear experiencias más ricas.
- Facilitar integración de spritesheets, animaciones por frame y reproducción de efectos/música.

Alcance

- Componentes nuevos: `Animation`, `Animator`, `AudioSource`/`AudioComponent`.
- Sistemas nuevos: `AnimationSystem`, `AudioSystem`.
- Integración con `AssetManager`, `RenderSystem` y `EventSystem`.
- Herramientas para declarar animaciones desde JSON/TS y empaquetar spritesheets.

Checklist (requerimientos)

- [ ] Definir data-shapes de componentes (types) y contratos de sistema.
- [ ] Implementar `AnimationSystem` que actualice frames en el fixed timestep.
- [ ] Implementar `AudioSystem` con reproducción, pausado y groups (music/sfx).
- [ ] Integración con `AssetManager` para cargar spritesheets y samples.
- [ ] API simple para que ejemplo `space-shooter` muestre animación y sonido de disparo.
- [ ] Tests unitarios (happy path + 2 edge cases).

Resumen técnico (Arquitecto)

- Animations son datos (componentes) y no estado complejo. El `AnimationSystem` debe ser determinista: actualizar frame index según `deltaTime` recibido por el `GameLoop`.
- Las animaciones se definen como secuencias de frames indexadas (o ranges en un spritesheet) y metadatos (loop, frameDuration, events).
- Recomendación: mantener un cache en `AnimationSystem` con referencias a `Texture`/`SpriteSheet` para evitar lookups repetidos.
- Audio debe ser manejado por una capa `AudioManager` que trabaje como facade sobre WebAudio API; `AudioSystem` en ECS traducirá componentes a llamadas a `AudioManager`.

Diseño de componentes (types)

- AnimationComponent

  - type: 'animation'
  - spriteSheet: string // nombre en AssetManager
  - animations: Record<string, { startFrame: number; endFrame: number; frameDuration: number; loop: boolean; events?: Array<{frame:number,name:string}> }>
  - current: { name: string; frameIndex: number; elapsed: number }

- AnimatorComponent (opcional separado si se desea separar datos de plantilla vs estado)

  - type: 'animator'
  - playing: boolean
  - speed: number
  - playOnStart: boolean

- AudioComponent
  - type: 'audio'
  - clip: string
  - loop?: boolean
  - volume?: number
  - group?: 'sfx' | 'music'

Contracts / APIs

- AnimationSystem

  - update(dt: number): por cada entidad con `animation` y `transform` actualizar `current.frameIndex` y emitir events definidos en animation.events usando `EventSystem`.
  - API pública: `play(entity, animationName)`, `stop(entity)`, `pause(entity)`, `setSpeed(entity, value)`.

- AudioManager (singleton)
  - loadAudio(name: string, url: string): Promise<void>
  - play(name: string, opts?: { loop?: boolean, volume?: number, group?: string }): PlaybackHandle
  - stop(handle|name)
  - setGroupVolume(group, volume)

Integración con `space-shooter` (ejemplo práctico)

- Animar la nave del jugador

  - Cargar spritesheet `nave_sprites.png` en `AssetManager` con key `nave_sprites`.
  - Definir animaciones: `idle`, `thrust`, `explosion`.
  - En el `createPlayer()` de space-shooter, agregar componente `animation` en lugar (o además) del `sprite` con `current.name = 'idle'`.

- Sonido de disparo
  - Cargar `laser_pixel.wav` con key `laser` en `AssetManager`.
  - Agregar `audio` component al prototipo de proyectil o llamar `AudioManager.play('laser', {group:'sfx'})` al crear proyectil.

Eventos útiles

- ANIMATION_EVENT.FRAME (emitted with { entity, animationName, frameIndex })
- AUDIO_EVENT.PLAY / STOP

Edge cases y tests

- Cambio de animación a mitad de frame: el sistema debe resetear elapsed y frameIndex si `play` con distinta animación.
- Entidades sin `sprite` deben ser toleradas (sirve sólo para lógica de estado).
- Test: play -> advance time -> assert frameIndex increment
- Test: play sound -> assert AudioManager received play call

Notas de performance

- Mantener lookups por entidad a O(1) usando arrays de entidades en `AnimationSystem`.
- Evitar re-registrar texturas cada frame; cachear referencias.

Migración y compatibilidad

- `sprite` sigue existiendo; `animation` puede ser añadido gradualmente.
- Documentar cambios en `examples/space-shooter` como referencia.

Tareas propuestas (mínimo entregable)

1. Types + interfaces
2. `AnimationSystem` básico (no events)
3. `AudioManager` facade y `AudioSystem` básico
4. Integración example `space-shooter` — animación nave + sfx
5. Tests y docs

Referencias

- WebAudio API
- Técnicas de spritesheets y atlases
- Event-driven animation triggers

---

_Sección: Diseño (Especialista en Patrones de Diseño)_

Pautas de patrones a aplicar

- Strategy: para diferentes políticas de interpolación (frame stepping, frameBlend) encapsular en strategies.
- Flyweight: spritesheet frames deben reutilizarse; las instancias de `Animation` pueden compartir metadata.
- Observer: `AnimationSystem` emite eventos de frame para suscriptores (por ejemplo, para triggers de sonido).
- Facade: `AudioManager` como fachada para WebAudio y fallback a HTMLAudio en navegadores limitados.

Ejemplo de patrón: Adapter

- Adapter para distintas fuentes de audio (AudioBuffer vs HTMLAudioElement) con interfaz `IAudioSource`.

Fin de documento

## Estado actual (progreso)

Resumen corto: la implementación básica de animaciones y audio está en la rama `feature/v0.3.0-animations-audio` y cubre tipos, sistemas, integración por eventos y tests unitarios para los casos principales.

Cambios implementados (estado "done"):

- `AnimationSystem`: actualiza frames determinísticamente, resuelve `SpriteSheet` vía `AssetManager` cuando está disponible, y emite eventos `ANIMATION_EVENTS.FRAME` y `ANIMATION_EVENTS.COMPLETE`.
- `AnimationComponent`: añadida la propiedad opcional `frameSfx?: { [frameIndex: number]: string }` para mapear frames a SFX.
- `AudioManager`: fachada básica sobre WebAudio con `loadAudio`, `play`, `stop`, `setGroupVolume` y `has`.
- `AudioSystem`: sistema ECS que
  - maneja `AudioComponent` (autoplay, lazy load, play/stop helpers),
  - se suscribe a `ANIMATION_EVENTS.FRAME` y reproduce SFX según `AnimationComponent.frameSfx` y según `AudioComponent.autoplayOnFrame/triggerFrame`.
- Tests: se añadieron/actualizaron tests unitarios relevantes:
  - `tests/unit/animation-system.test.ts` (verifica avance de frames y emisión de FRAME/COMPLETE)
  - `tests/unit/audio-system.test.ts` (verifica reproducción en respuesta a FRAME y la lógica `frameSfx` y `autoplayOnFrame`)

Archivos modificados/creados clave:

- `src/graphics/Animation.ts` (types + `frameSfx`)
- `src/graphics/AnimationSystem.ts` (emisión de eventos, resolución de spritesheets)
- `src/audio/AudioManager.ts` (facade WebAudio)
- `src/audio/AudioSystem.ts` (suscripción a eventos, playback logic)
- `tests/unit/animation-system.test.ts` (actualizado)
- `tests/unit/audio-system.test.ts` (nuevo)

Pruebas y verificación:

- Unit tests relevantes ejecutados y pasando (local):
  - `tests/unit/animation-system.test.ts` — PASS
  - `tests/unit/audio-system.test.ts` — PASS
- `EventSystem` en entorno de test procesa eventos inmediatamente para permitir aserciones sin esperar el bucle principal.

Pendiente / próximos pasos (priorizados):

1. Integrar en `examples/space-shooter`: añadir `frameSfx` a la nave / proyectiles y cargar samples en `AssetManager` para tener un demo manual.
2. Añadir tests de integración end-to-end que avancen `AnimationSystem.update()` y verifiquen que `AudioSystem` actúa en consecuencia.
3. Documentar en el README del ejemplo los pasos para reproducir la demo (carga de assets, configuración de componentes).
4. (Opcional) Suavizado de SFX: debounce/throttle para evitar reproducciones repetidas en frames rápidos; política de prioridad entre `frameSfx` y `AudioComponent` si se quiere evitar dobles reproducciones.

Notas adicionales:

- La rama actual es `feature/v0.3.0-animations-audio`. Recomiendo abrir un PR con esta rama cuando quieras revisar cambios y mergearlos a `develop`/`main`.
- Si prefieres que continue con un cambio específico ahora (docs extendida, ejemplo actualizado o tests de integración), indícalo y lo implemento en seguida.
