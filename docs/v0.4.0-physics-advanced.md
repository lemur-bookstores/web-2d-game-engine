# v0.4.0 - Física Avanzada

Propósito

- Integrar una solución de física robusta (Box2D via WASM o similar) para soportar cuerpos dinámicos, estáticos, joints, constraints y simulaciones deterministas.
- Exponer una API ECS-friendly que permita mapear componentes a cuerpos físicos y sincronizar transform entre Box2D y el `Transform` del ECS.

Alcance

- Integración de Box2D WebAssembly como dependencia opcional.
- Nuevo componente `physicsBody` con mapeo a Box2D body.
- Wrapper `PhysicsWorld` que abstrae detalles de Box2D y expone métodos simples (createBody, destroyBody, step).
- Soporte para joints (revolute, distance, rope, etc.) y collision layers.
- Eventos de contacto bien definidos usando `EventSystem`.

Checklist (requerimientos)

- [ ] Diseñar `PhysicsBody` component shape y sync rules
- [ ] Implementar `PhysicsWorld` con carga de WASM y fallback
- [ ] Mapear ciclo de vida: crear cuerpo al agregar componente, destruir al remover
- [ ] Implementar `PhysicsSystem` que llame a `PhysicsWorld.step()` en el fixed timestep y sincronice transform
- [ ] Exponer API para joints y constraints
- [ ] Proveer ejemplos (platformer y brick-breaker) usando cuerpos Box2D
- [ ] Tests de integridad y reproducibilidad

Resumen técnico (Arquitecto)

- Integración como servicio: `PhysicsWorld` es singleton por escena (o por engine) y actúa como fuente de verdad para posiciones físicas.
- Debe ejecutarse en el mismo fixed timestep del `GameLoop` para mantener determinismo (por ejemplo 60Hz con substeps configurables).
- Tener opción para ejecutar Box2D en web-worker si se necesita offloading (pero inicialmente simple en main thread).
- Sincronización: después de `step()`, actualizar `transform.position` y opcionalmente `transform.rotation` de entidades que tengan `physicsBody`.

Diseño de componentes (types)

- PhysicsBodyComponent
  - type: 'physicsBody' | 'physics'
  - bodyType: 'dynamic' | 'static' | 'kinematic'
  - shape: 'box' | 'circle' | 'polygon'
  - width?, height?, radius?, vertices?
  - density, friction, restitution
  - fixedRotation?: boolean
  - isSensor?: boolean
  - collisionGroup?: number

Contracts / APIs

- PhysicsWorld
  - initialize(options)
  - createBody(entity, bodyDef): Box2DBodyRef
  - destroyBody(bodyRef)
  - step(dt)
  - queryAABB(aabb): Entity[]

- PhysicsSystem
  - onEntityAdded(entity): create body if component present
  - update(dt): call world.step(dt); sync transforms
  - onEntityRemoved(entity): destroy body

Eventos

- PHYSICS_EVENTS.COLLISION_BEGIN { entityA, entityB, contact }
- PHYSICS_EVENTS.COLLISION_END { entityA, entityB }
- PHYSICS_EVENTS.JOINT_BREAK { jointId }

Patrones de diseño (Especialista en Patrones)

- Adapter: envolver la API de Box2D en un adaptador `Box2DAdapter` para desacoplar el motor de la librería concreta.
- Facade: `PhysicsWorld` como fachada minimalista para crear cuerpos y joints.
- Observer: usar `EventSystem` para propagar colisiones y resolver respuestas (por ejemplo vida, efectos).
- Command: para acciones que modifican el mundo (crearJoint, applyImpulse) que pueden ser encoladas y reproducidas en tests.

Concurrencia y rendimiento

- Substepping: permitir configuración de substeps para estabilidad en cuerpos rápidos.
- Pooling: reuse fixtures/shapes cuando sea posible.
- Worker: planear como mejora (v0.5) para offload; hoy no obligatorio.

Migración y compatibilidad

- El componente `physics` existente debe mantenerse como alias para `physicsBody` si aún se usa por ejemplos actuales.
- Documentar cómo convertir `physics` simple a `physicsBody` avanzado.

Ejemplo práctico (Platformer)

1. Definir componente en entidad "player":

```ts
player.addComponent({
  type: 'physicsBody',
  bodyType: 'dynamic',
  shape: 'box',
  width: 32,
  height: 64,
  density: 1,
  friction: 0.2,
  restitution: 0,
  fixedRotation: true
});
```

2. PhysicsSystem al inicio crea body y añade fixture. En cada step, `PhysicsSystem` sincroniza:

```ts
const bodyPos = body.GetPosition();
transform.position.x = bodyPos.x * SCALE; // si se usa conversión de unidades
transform.position.y = bodyPos.y * SCALE;
transform.rotation = body.GetAngle();
```

Eventos de colisión

- Al detectar contacto, `PhysicsWorld` emite `PHYSICS_EVENTS.COLLISION_BEGIN` con referencias a las entidades. La lógica del juego suscribe y reacciona (por ejemplo, restar vida).

Tests y validación

- Validar reproducibilidad: correr 1000 pasos y comparar posiciones con referencia.
- Tests de integridad al crear/destroy bodies repetidamente (memory leak).

Tareas propuestas (mínimo entregable)

1. `Box2DAdapter` + `PhysicsWorld` básico
2. `PhysicsSystem` que sincronice transform
3. Tests de colisiones simples
4. Ejemplo `platformer` usando cuerpos Box2D

Notas finales

- Versionar la integración y documentar la versión de Box2D WASM usada.
- Mantener fallback simple (PhysicsSystem existente) si WASM no está disponible.

---

_Sección: Diseño (Especialista en Patrones de Diseño)_

Patrones recomendados

- Adapter para desacoplar Box2D
- Facade para presentar API simple al resto del engine
- Strategy para seleccionar integrador (Euler semi-implicito vs substeps)
- Command para reproducir acciones físicas en tests

Fin de documento
