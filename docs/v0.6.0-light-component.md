# v0.6.0 - Light Component & Lighting System

Resumen

- Añade soporte de iluminación (componentes de luz, sistema de iluminación, registro de tipos de luz).
- Integra luces con Camera2D (culling), Layers (visibilidad/opacidad) y RenderSystem (blend / shader / fallback).
- Provee metadata para editor/inspector y helpers de serialización / rehidratación.
- Objetivo: sistema extensible (point, spot, directional, lightmaps) con buen rendimiento en WebGL y fallback a Canvas2D.

Motivación

- Permitir efectos de iluminación dinámicos y dirigibles por entidades.
- Facilitar edición en runtime (inspector) y serialización segura para escenas y ejemplos.
- Soportar múltiples tipos de fuentes de luz y control por capas para compositing.

Conceptos clave

- LightComponent: datos puros (serializables) que describen una luz.
- LightRegistry: registra tipos de luz, props/metadatos y mappers para inspector.
- LightingSystem: procesa luces visibles en el viewport/cámara, aplica efectos en renderer (WebGL shader o Canvas2D fallback), respeta layer order/opacity.
- Inspector: UI que usa metadata del registry para mostrar controles de edición dinámicos.

LightComponent (sugerencia de fields)

- type: 'point' | 'spot' | 'directional' | 'ambient' | string
- color: { r: number, g: number, b: number, a?: number }
- intensity: number
- range: number // para point/spot
- angle: number // para spot (radians)
- castsShadow: boolean
- shadowBias?: number
- falloff?: 'linear'|'quadratic'|'none'
- layer?: string | number // layer identifier o bit
- visible?: boolean
- sortPriority?: number // orden dentro de la misma capa
- offset?: { x:number, y:number } // relativo al transform
- shadowMapSettings?: { resolution?: number, maxDistance?: number } // opcional

Notas:

- Mantener campos primitivas/POJOs para serialización segura.
- No almacenar referencias a Entity, Texture, Context, etc.

LightRegistry

- Responsabilidad:
  - Registrar tipos de luz con metadata (fields, tipos, labels, ranges).
  - Registrar mappers/normalizers para propiedades complejas (Vector, Color, PhysicsBody).
  - Exponer API para el inspector:
    - getRegisteredLights(): string[]
    - getLightMetadata(name: string): LightMetadata
    - createDefaultComponent(name: string): LightComponent
- Extensible: permitir `registerTypeMapper` (similar a ScriptRegistry) para tipos complejos.

LightingSystem

- Responsabilidad:
  - Recopilar luces activas por escena (filtrar por visible, layer & layer visibility, camera frustum).
  - Ordenar luces por layer order -> sortPriority -> distance (opcional).
  - Aplicar blend/lights en renderer:
    - WebGLRenderer: shader-based (deferred/forward) y shadow maps si disponible.
    - Canvas2DRenderer: blob lights, additive blending y simple shadow approximation.
  - Culling:
    - Usar Camera2D.worldToScreen + light range to skip offscreen lights.
    - Opcional quadtree/spatial index para escenas con muchas luces.
  - Lifecycle:
    - Init/destroy hooks, respond to entity removal to free shadow maps/resources.
    - Respects engine pause / layer opacity (modificar global alpha por layer o por luz).
- API pública (ejemplos):
  - setMaxActiveLights(n: number)
  - setLayerOrder([ 'background', 'world', 'player', 'ui' ])
  - enableShadows(enabled: boolean)

Integración con Camera2D y Layers

- Camera2D: LightingSystem debe recibir la cámara activa para culling y cálculo en screen space.
- Layers:
  - LightingSystem respeta layer.visible and layer.opacity.
  - Las luces sólo afectan entidades/environments en capas permitidas (layer mask).
  - Layer opacity multiplica la contribución de la luz al render.

WebGL vs Canvas2D fallback

- Preferir WebGL shader pipeline para calidad y sombras.
- Canvas2D fallback:
  - Dibujar luces como gradientes/blurred circles con globalCompositeOperation = 'lighter' o 'screen'.
  - Simple occlusion: desenfoque y blob lights; evitar costosas shadow maps.
- Detectar capacidades del renderer y elegir estrategia en inicialización.

Serialización / Save-Load

- LightComponent debe ser completamente serializable (POJOs).
- Uso recomendado:
  - Al guardar escena: LightingSystem / ScriptRegistry -> obtener state via registry.getAllProperties(instanceId) o simplemente el componente LightComponent.
  - Al cargar escena: LightRegistry.createDefaultComponent + aplicar component.state o setAllProperties para rehidratar.
- Guardar shadow map RAW no recomendado; recomputar al cargar.

Inspector / Editor

- El inspector usará LightRegistry metadata para:
  - Generar controles: color picker, sliders (range/intensity), toggles (castsShadow).
  - Mostrar preview minimal (gizmo) con la cámara actual.
- Implementación ejemplo (en examples/):
  - Panel izquierdo lista entidades con LightComponent.
  - Panel derecho muestra propiedades (tipo, color, range).
  - Edición aplica cambios en tiempo real: update instancia proxy OR setComponent.state.
- Reglas:
  - Validar y sanitizar entradas en el inspector antes de aplicar (clamp numeric ranges).
  - Para tipos complejos (Vector/Color) usar widgets especializados.

Detección y normalización de tipos complejos

- Reutilizar `typeMappers` (ya presente en ScriptRegistry) o exponer uno similar en LightRegistry.
- Mappers built-in sugeridos:
  - vector -> { x:number, y:number }
  - color -> { r:number, g:number, b:number, a:number }
  - physicsBody summary -> { width:number, height:number, position:{x,y} }
- Exponer API para registrar mappers personalizados.

Tests recomendados

- Unit:
  - extractPublicProperties (metadata) reconoce color/vector.
  - getAllProperties / setAllProperties roundtrip en LightRegistry.
  - Culling: lights fuera del viewport son ignoradas.
  - Layer opacity/visibility afecta resultado (mock renderer).
  - Fallback Canvas2D pipeline produce draw calls esperadas (mocks).
- Integration:
  - Save/Load roundtrip: crear escena con luces, serialize -> deserialize -> run -> lights match.
  - Inspector apply: modificar desde UI y comprobar cambios en runtime.
- Performance:
  - Stress test con N lights + culling/quadtree enabled para medir active lights cap.

Ejemplos a añadir (inmediatos)

- examples/lights/basic-point: point light fijo, sin sombras.
- examples/lights/layers-demo: luces en distintas capas, mostrar layer opacity toggle.
- examples/lights/inspector-demo: inspector UI que edita propiedades en runtime y save/load.
- examples/lights/shadows-demo: (opcional) WebGL shadow map demo.

Tareas de implementación (prioridad)

1. API: exponer metadata y mappers en `src/light/LightRegistry.ts`.
2. Component: definir `LightComponent.ts` con fields serializables y defaults.
3. System: Implementar `LightingSystem.ts` básico (culling + additive blend) y WebGL shader stub.
4. Inspector: añadir UI en `examples/script-component` o nueva `examples/lights/inspector-demo`.
5. Tests: añadir unidad e integración (tests/unit/light.\*.test.ts).
6. Docs: actualizar `docs/v0.6.0-light-component.md` (este archivo).
7. Performance: agregar quadtree opcional y cap de luces activas.

Buenas prácticas

- Mantén LightComponent como POJO: facilita serialización y seguridad.
- Preferir metadata-driven editors en lugar de schema manual repetitivo.
- No serializar referencias (Entity, callbacks). Serializar solo valores PRIMITIVOS/POJOs.
- Throttle serialización e inspector updates (no cada frame).
- Evitar proxificar objetos en hot-path; usar proxies solo para editor-bound instances.

Compatibilidad con el resto del engine

- Respeta Camera2D transform, RenderSystem layer ordering, Scene layer opacity/visibility.
- Registrar Light types en `LightRegistry` para que el inspector y save/load funcionen de forma consistente.
- Integrar con existing ScriptRegistry type mappers si comparten tipos (Vector/Color), reusar util.

Notas finales

- Diseño incremental: empezar con point lights + additive blend + culling. Agregar shadows y shaders después.
- Mantener API opt‑in para editor features; default runtime sin overhead adicional.
- Puedo implementar los pasos 1-3 y añadir tests básicos si confirmas
