# v0.5.1 - Script Component

## Resumen

Agregar soporte formal para "scripts" como componentes reutilizables que definen comportamiento por entidad. Esto permitirá anexar lógica (init/update/destroy) a entidades manteniendo la arquitectura ECS: datos en componentes, lógica centralizada en sistemas.

## Objetivo

- Implementar `ScriptComponent` (serializable) y `ScriptSystem` (ejecutor de hooks).
- Añadir `ScriptRegistry` para mapear nombres de script a clases/fábricas y permitir rehidratación desde JSON.
- Proveer ejemplo `PlayerController` y documentación de uso.

## Entregables

- `src/ecs/ScriptComponent.ts` (tipo y utilidades)
- `src/ecs/ScriptSystem.ts` (sistema que crea instancias y llama init/update/destroy)
- `src/ecs/ScriptRegistry.ts` (registro global para factories/classes)
- `tests/unit/script.system.test.ts` (unit tests: lifecycle y rehidratación)
- `examples/script-component/` (demo pequeño con player controller)
- Docs: `docs/v0.5.1-script-component.md` (este archivo)
- README update (roadmap) — already added

## Requisitos detallados

1. ScriptComponent

- Debe ser serializable: guardar `scriptName?: string` y `state?: any`.
- En runtime puede contener `instance?: ScriptInstance` para ejecución.

2. ScriptInstance interface

- Hooks opcionales: `init?()`, `update?(dt:number)`, `destroy?()`.
- Métodos de (de)serialización opcionales: `toJSON?()` / `fromJSON?(data:any)`.

3. ScriptRegistry

- API simple: `register(name, ctor)`, `create(name, ...args)`.
- Usar para rehidratación cuando `ScriptComponent` tiene `scriptName`.

4. ScriptSystem

- Iterar entidades con componente `script`.
- Si `script.scriptName` y no hay `instance`, crear usando registry, asignar entidad y estado, llamar `init()`.
- En cada update, llamar `instance.update(dt)` si existe.
- En destroy/when removing component, llamar `instance.destroy()`.

5. Seguridad

- No usar `eval` ni `new Function` para código arbitrario en producción.
- Soportar inyección de instancias solo en modo dev/editor bajo control explícito.

## Plan de trabajo (milestones)

- M1: Definir tipos y registry (small, testable)
- M2: Implementar ScriptSystem y tests básicos (lifecycle)
- M3: Ejemplo y docs; integración en README
- M4: Tests de serialización y rehidratación + CI smoke

## Tests propuestos

- Instanciar script por name y verificar `init` llamado.
- Verificar `update` llamado cada frame.
- Serializar entidad con `scriptName` + state y rehidratala; comprobar `fromJSON` aplicado.

## Criterios de aceptación

- `ScriptSystem` crea/gestiona correctamente instancias de scripts.
- Scripts serializados y rehidratados mantienen estado esperado.
- No se usa eval ni ejecución de código arbitrario por defecto.
- Ejemplo funcional en `examples/script-component/`.

## Tareas (issues sugeridos)

- feat(script): add ScriptComponent type
- feat(script): add ScriptRegistry
- feat(script): implement ScriptSystem
- test(script): lifecycle and serialization tests
- docs(example): add script-component example and docs

## Notas

- Mantener API simple y explícita: scriptName en componentes, registry para factories.
- En el editor futuro, se podrá inyectar instancias de scripts para editar comportamiento en caliente, pero la serialización debe seguir usando `scriptName`.

## Ejemplo: Wiring Save / Load (Editor or UX)

Si quieres exponer guardado y carga de escenas o permitir que un editor use los estados serializables de los scripts, puedes usar `scriptName` junto con el estado del componente. El siguiente ejemplo demuestra una estrategia simple:

- Al serializar una escena, para cada script intenta usar `instance.getAllProperties()` cuando esté disponible. Esto garantiza que los valores runtime (posición, colores, vectores) se persistan usando los mappers registrados en `ScriptRegistry`.
- Al cargar, crea entidades y componentes con `scriptName` y `state` (la `ScriptSystem` se encargará de rehidratar con `setAllProperties` automaticamente en el siguiente frame).

Snippet (concepto):

```
// Serializar: para cada componente script -> { scriptName, state: instance.getAllProperties() }
// Guardar JSON en disco desde la UI (download blob)

// Al cargar JSON, crear entidades y componentes con la misma forma.
// ScriptSystem en runtime creara instancias y llamara setAllProperties(state).
```

En el repo hay un ejemplo funcional en `examples/script-component/index.ts` que añade botones "Save Scene" y "Load Scene" demostrando exactamente este flujo.
